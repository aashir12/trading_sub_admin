import { initializeApp } from 'firebase/app';
import {
  doc,
  addDoc,
  getDocs,
  deleteDoc,
  collection,
  getFirestore,
  query,
  where,
  updateDoc,
  setDoc,
} from 'firebase/firestore';

// TODO: Add SDKs for Firebase products that you want to use
// https://firebase.google.com/docs/web/setup#available-libraries

// Your web app's Firebase configuration

export const firebaseConfig = {
  apiKey: import.meta.env.VITE_FIREBASE_API_KEY || '',
  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN || '',
  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID || '',
  storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET || '',
  messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID || '',
  appId: import.meta.env.VITE_FIREBASE_APP_ID || '',
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// Define the type for archive document data
interface ArchiveDocument {
  title: string;
  description: string;
  record?: string; // Optional field for archive entries
  imageUrl?: string; // Optional field for archive entries
  relatedLinks?: string; // Optional field for archive entries
  approach?: string; // Optional field for archive entries
  introductoryText?: string; // Optional field for archive entries
  regionHistory?: string; // Optional field for archive entries
}

interface AdminDocument {
  name: string;
  username: string;
  password: string;
}

interface Archive1Document {
  title: string;
  location: string;
  assets: string;
  material: string;
  relatedLinks: string;
  relatedAssets: string;
  date: string;
  supportedBy: string;
}

interface NotificationDocument {
  id?: string; // Optional, as it will be generated by Firestore for main notifications
  message: string;
  read: boolean;
  type: string;
  refferal: string;
  createdAt: Date;
  image: string; // New: base64 or URL
  title: string; // New: notification title
}

// Middleware functions for archive
const addAdminEntry = async (docData: {
  name: string;
  username: string;
  password: string;
  refferal: string;
}) => {
  try {
    const docRef = await addDoc(collection(db, 'sub_admins'), docData);
    console.log('User entry added with ID:', docRef.id);
    return docRef.id; // Return the document ID
  } catch (error) {
    console.error('Error adding user entry:', error);
    throw new Error(error.message);
  }
};

const fetchAdminEntries = async () => {
  try {
    const querySnapshot = await getDocs(collection(db, 'sub_admins'));
    return querySnapshot.docs.map((docData) => {
      const data = docData.data() as ArchiveDocument; // Cast to ArchiveDocument
      return { id: docData.id, ...data }; // Include document ID
    });
  } catch (error) {
    console.error('Error fetching admin data:', error);
    throw new Error(error.message);
  }
};

// Middleware functions for archive1
const addArchive1Entry = async (docData: {
  title: string;
  location: string;
  assets: string;
  material: string;
  relatedLinks: string;
  relatedAssets: string;
  date: string;
  supportedBy: string;
}) => {
  try {
    const docRef = await addDoc(collection(db, 'archive1'), docData);
    console.log('Archive1 entry added with ID:', docRef.id);
    return docRef.id; // Return the document ID
  } catch (error) {
    console.error('Error adding archive1 entry:', error);
    throw new Error(error.message);
  }
};

// Middleware functions for glossary
const addGlossaryEntry = async (title: string, description: string) => {
  const docData = { title, description };
  try {
    const docRef = await addDoc(collection(db, 'archives'), docData); // Use 'glossary' collection
    console.log('Glossary entry added with ID:', docRef.id);
    return docRef.id; // Return the document ID
  } catch (error) {
    console.error('Error adding glossary entry:', error);
    throw new Error(error.message);
  }
};

const fetchGlossaryEntries = async () => {
  try {
    const querySnapshot = await getDocs(collection(db, 'archives')); // Use 'glossary' collection
    return querySnapshot.docs.map((docData) => {
      const data = docData.data() as ArchiveDocument; // Cast to ArchiveDocument
      return { id: docData.id, ...data }; // Include document ID
    });
  } catch (error) {
    console.error('Error fetching glossary data:', error);
    throw new Error(error.message);
  }
};

// Middleware functions for map
const addMapEntry = async (docData: {
  projectTitle: string;
  placeName: string;
  date: string;
  description: string;
  longitude: string;
  latitude: string;
  assets: string;
  material: string;
  archiveLink: string;
  relatedLink: string;
  location: string;
}) => {
  try {
    const docRef = await addDoc(collection(db, 'routes'), docData); // Use 'map' collection
    console.log('Map entry added with ID:', docRef.id);
    return docRef.id; // Return the document ID
  } catch (error) {
    console.error('Error adding map entry:', error);
    throw new Error(error.message);
  }
};

const fetchMapEntries = async () => {
  try {
    const querySnapshot = await getDocs(collection(db, 'routes')); // Use 'map' collection
    return querySnapshot.docs.map((docData) => {
      const data = docData.data(); // Cast to appropriate type if needed
      return { id: docData.id, ...data }; // Include document ID
    });
  } catch (error) {
    console.error('Error fetching map data:', error);
    throw new Error(error.message);
  }
};

const fetchArchive1Entries = async () => {
  try {
    const querySnapshot = await getDocs(collection(db, 'archive1'));
    return querySnapshot.docs.map((docData) => {
      const data = docData.data() as Archive1Document;
      return { id: docData.id, ...data };
    });
  } catch (error) {
    console.error('Error fetching archive1 data:', error);
    throw new Error(error.message);
  }
};

// fetch users
const fetchUserEntries = async () => {
  try {
    const querySnapshot = await getDocs(collection(db, 'users')); // Use 'map' collection
    return querySnapshot.docs.map((docData) => {
      const data = docData.data(); // Cast to appropriate type if needed
      return { id: docData.id, ...data }; // Include document ID
    });
  } catch (error) {
    console.error('Error fetching map data:', error);
    throw new Error(error.message);
  }
};

const fetchUsersByRefferal = async (refferal: string) => {
  try {
    const usersRef = collection(db, 'users');
    const q = query(usersRef, where('referral', '==', refferal));
    const querySnapshot = await getDocs(q);
    return querySnapshot.docs.map((docData) => {
      const data = docData.data();
      return { id: docData.id, ...data };
    });
  } catch (error) {
    console.error('Error fetching users by referral:', error);
    throw new Error(error.message);
  }
};

// Delete functions for all collections
const deleteUserEntry = async (id: string) => {
  try {
    await deleteDoc(doc(db, 'users', id)); // Delete document by ID
    console.log('Admin entry deleted with ID:', id);
  } catch (error) {
    console.error('Error deleting admin entry:', error);
    throw new Error(error.message);
  }
};

const updateUserBalance = async (userId: string, newBalance: number) => {
  try {
    const balanceDocRef = doc(db, 'users', userId, 'balance', 'main');
    await updateDoc(balanceDocRef, { availableBalance: newBalance });
    console.log('User balance updated successfully for user:', userId);
  } catch (error) {
    console.error('Error updating user balance:', error);
    throw new Error(error.message);
  }
};

const updateUserFreezeBalance = async (userId: string, frozenAmount: number) => {
  try {
    const balanceDocRef = doc(db, 'users', userId, 'balance', 'main');
    await updateDoc(balanceDocRef, { frozenBalance: frozenAmount });
    console.log('User frozen balance updated successfully for user:', userId, 'to', frozenAmount);
  } catch (error) {
    console.error('Error updating user frozen balance:', error);
    throw new Error(error.message);
  }
};

// Delete functions for all collections
const deleteAdminEntry = async (id: string) => {
  try {
    await deleteDoc(doc(db, 'sub_admins', id)); // Delete document by ID
    console.log('Admin entry deleted with ID:', id);
  } catch (error) {
    console.error('Error deleting admin entry:', error);
    throw new Error(error.message);
  }
};

const deleteArchive1Entry = async (id: string) => {
  try {
    await deleteDoc(doc(db, 'archive1', id)); // Delete document by ID
    console.log('Archive entry deleted with ID:', id);
  } catch (error) {
    console.error('Error deleting archive entry:', error);
    throw new Error(error.message);
  }
};

const deleteGlossaryEntry = async (id: string) => {
  try {
    await deleteDoc(doc(db, 'archives', id)); // Delete document by ID
    console.log('Glossary entry deleted with ID:', id);
  } catch (error) {
    console.error('Error deleting glossary entry:', error);
    throw new Error(error.message);
  }
};

const deleteMapEntry = async (id: string) => {
  try {
    await deleteDoc(doc(db, 'routes', id)); // Delete document by ID
    console.log('Map entry deleted with ID:', id);
  } catch (error) {
    console.error('Error deleting map entry:', error);
    throw new Error(error.message);
  }
};

// Middleware functions for notifications
const addNotification = async (docData: Omit<NotificationDocument, 'id'>) => {
  try {
    const docRef = await addDoc(collection(db, 'notifications'), docData);
    console.log('Notification added with ID:', docRef.id);
    return docRef.id;
  } catch (error) {
    console.error('Error adding notification:', error);
    throw new Error(error.message);
  }
};

const getWithdrawlRequest = async (userId: string) => {
  try {
    const withdrawRef = collection(db, 'users', userId, 'reviewWithdraw');
    const querySnapshot = await getDocs(withdrawRef);
    return querySnapshot.docs.map((docData) => ({
      id: docData.id,
      ...docData.data(),
    }));
  } catch (error) {
    console.error('Error fetching withdrawal requests:', error);
    throw new Error(error.message);
  }
};

const getNotificationsByRefferal = async (refferal: string) => {
  try {
    const notificationsRef = collection(db, 'notifications');
    const q = query(notificationsRef, where('refferal', '==', refferal));
    const querySnapshot = await getDocs(q);
    return querySnapshot.docs.map((docData) => ({
      id: docData.id,
      ...docData.data(),
    }));
  } catch (error) {
    console.error('Error fetching notifications by referral:', error);
    throw new Error(error.message);
  }
};

const addUserNotification = async (
  userId: string,
  notificationId: string,
  notificationData: Omit<NotificationDocument, 'id'>
) => {
  try {
    const userNotificationRef = doc(db, 'users', userId, 'notifications', notificationId);
    // Ensure the ID is passed to the user's notification document
    await setDoc(userNotificationRef, { id: notificationId, ...notificationData });
    console.log(`Notification ${notificationId} added to user ${userId}`);
  } catch (error) {
    console.error(`Error adding notification to user ${userId}:`, error);
    throw new Error(error.message);
  }
};

const deleteNotification = async (notificationId: string) => {
  try {
    await deleteDoc(doc(db, 'notifications', notificationId));
    console.log('Notification deleted from main collection:', notificationId);
  } catch (error) {
    console.error('Error deleting notification:', error);
    throw new Error(error.message);
  }
};

const deleteUserNotification = async (userId: string, notificationId: string) => {
  try {
    await deleteDoc(doc(db, 'users', userId, 'notifications', notificationId));
    console.log(`Notification ${notificationId} deleted from user ${userId}'s collection.`);
  } catch (error) {
    console.error(`Error deleting notification from user ${userId}'s collection:`, error);
    throw new Error(error.message);
  }
};

const updateNotification = async (
  notificationId: string,
  updatedData: Partial<NotificationDocument>
) => {
  try {
    await updateDoc(doc(db, 'notifications', notificationId), updatedData);
    console.log('Notification updated in main collection:', notificationId);
  } catch (error) {
    console.error('Error updating notification:', error);
    throw new Error(error.message);
  }
};

const updateUserNotification = async (
  userId: string,
  notificationId: string,
  updatedData: Partial<NotificationDocument>
) => {
  try {
    await updateDoc(doc(db, 'users', userId, 'notifications', notificationId), updatedData);
    console.log(`Notification ${notificationId} updated in user ${userId}'s collection.`);
  } catch (error) {
    console.error(`Error updating notification in user ${userId}'s collection:`, error);
    throw new Error(error.message);
  }
};

const getDepositRequest = async (userId: string) => {
  try {
    const depositRef = collection(db, 'users', userId, 'reviewDeposit');
    const querySnapshot = await getDocs(depositRef);
    return querySnapshot.docs.map((docData) => ({
      id: docData.id,
      ...docData.data(),
    }));
  } catch (error) {
    console.error('Error fetching deposit requests:', error);
    throw new Error(error.message);
  }
};

// Support Ticket Types
export interface SupportTicket {
  id?: string;
  userEmail: string;
  subject: string;
  message: string;
  status: string;
  createdAt: any; // Firestore Timestamp or Date
}

// Fetch all support tickets, with optional status filter and search
const fetchSupportTickets = async (options?: {
  status?: string;
  search?: string;
}): Promise<SupportTicket[]> => {
  try {
    let q: any = collection(db, 'support_tickets');
    const constraints: any[] = [];
    if (options?.status) {
      constraints.push(where('status', '==', options.status));
    }
    if (options?.search) {
      // Search by userEmail or subject (case-insensitive)
      // Firestore does not support OR queries, so fetch all and filter in JS
      const querySnapshot = await getDocs(q);
      const search = options.search ?? '';
      return querySnapshot.docs
        .map((docData) => {
          const data: any = docData.data() || {};
          return {
            id: docData.id,
            userEmail: data.userEmail || '',
            subject: data.subject || '',
            message: data.message || '',
            status: data.status || '',
            createdAt: data.createdAt || new Date(),
          };
        })
        .filter(
          (ticket) =>
            ticket.userEmail.toLowerCase().includes(search.toLowerCase()) ||
            ticket.subject.toLowerCase().includes(search.toLowerCase())
        ) as SupportTicket[];
    }
    if (constraints.length > 0) {
      q = query(q, ...constraints);
    }
    const querySnapshot = await getDocs(q);
    return querySnapshot.docs.map((docData) => {
      const data: any = docData.data() || {};
      return {
        id: docData.id,
        userEmail: data.userEmail || '',
        subject: data.subject || '',
        message: data.message || '',
        status: data.status || '',
        createdAt: data.createdAt || new Date(),
      };
    }) as SupportTicket[];
  } catch (error) {
    console.error('Error fetching support tickets:', error);
    throw new Error(error.message);
  }
};

// Update support ticket status
const updateSupportTicketStatus = async (ticketId: string, newStatus: string) => {
  try {
    await updateDoc(doc(db, 'support_tickets', ticketId), { status: newStatus });
    console.log('Support ticket status updated:', ticketId, newStatus);
  } catch (error) {
    console.error('Error updating support ticket status:', error);
    throw new Error(error.message);
  }
};

// Delete a support ticket by ID
const deleteSupportTicket = async (ticketId: string) => {
  try {
    await deleteDoc(doc(db, 'support_tickets', ticketId));
    console.log('Support ticket deleted:', ticketId);
  } catch (error) {
    console.error('Error deleting support ticket:', error);
    throw new Error(error.message);
  }
};

// Controller functions
export const firebaseController = {
  fetchUserEntries: async () => fetchUserEntries(),
  deleteUserEntry: async (id: string) => deleteUserEntry(id),
  fetchUsersByRefferal: async (refferal: string) => fetchUsersByRefferal(refferal),
  updateUserBalance: async (userId: string, newBalance: number) =>
    updateUserBalance(userId, newBalance),
  updateUserFreezeBalance: async (userId: string, frozenAmount: number) =>
    updateUserFreezeBalance(userId, frozenAmount),

  addNotification: async (docData: Omit<NotificationDocument, 'id'>) => addNotification(docData),
  getNotificationsByRefferal: async (refferal: string) => getNotificationsByRefferal(refferal),
  addUserNotification: async (
    userId: string,
    notificationId: string,
    notificationData: Omit<NotificationDocument, 'id'>
  ) => addUserNotification(userId, notificationId, notificationData),
  deleteNotification: async (notificationId: string) => deleteNotification(notificationId),
  deleteUserNotification: async (userId: string, notificationId: string) =>
    deleteUserNotification(userId, notificationId),
  updateNotification: async (notificationId: string, updatedData: Partial<NotificationDocument>) =>
    updateNotification(notificationId, updatedData),
  updateUserNotification: async (
    userId: string,
    notificationId: string,
    updatedData: Partial<NotificationDocument>
  ) => updateUserNotification(userId, notificationId, updatedData),

  addMapEntry: async (docData: {
    date: string;
    description: string;
    longitude: string;
    latitude: string;
    projectTitle: string;
    placeName: string;
    assets: string;
    material: string;
    archiveLink: string;
    relatedLink: string;
    location: string;
  }) => addMapEntry(docData),
  fetchMapEntries: async () => fetchMapEntries(),
  deleteMapEntry: async (id: string) => deleteMapEntry(id),

  addGlossaryEntry: async (title: string, description: string) =>
    addGlossaryEntry(title, description),
  getGlossaryEntries: async () => fetchGlossaryEntries(),
  deleteGlossaryEntry: async (id: string) => deleteGlossaryEntry(id),

  addAdminEntry: async (docData: {
    name: string;
    username: string;
    password: string;
    refferal: string;
  }) => addAdminEntry(docData),
  getAdminEntries: async () => fetchAdminEntries(),
  deleteAdminEntry: async (id: string) => deleteAdminEntry(id),

  addArchive1Entry: async (docData: {
    title: string;
    location: string;
    assets: string;
    material: string;
    relatedLinks: string;
    relatedAssets: string;
    date: string;
    supportedBy: string;
  }) => addArchive1Entry(docData),
  getArchive1Entries: async () => fetchArchive1Entries(),
  getWithdrawlRequest: async (userId: string) => getWithdrawlRequest(userId),
  getDepositRequest,
  fetchSupportTickets: async (options?: { status?: string; search?: string }) =>
    fetchSupportTickets(options),
  updateSupportTicketStatus: async (ticketId: string, newStatus: string) =>
    updateSupportTicketStatus(ticketId, newStatus),
  deleteSupportTicket: async (ticketId: string) => deleteSupportTicket(ticketId),
};
